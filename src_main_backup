#include <stdio.h>
#include <string.h>
#include <tusb.h>
#include <pico/stdlib.h>
#include "usbSerialDebug/helper.h"
#include <FreeRTOS.h>
#include <queue.h>
#include <task.h>
#include "tkjhat/sdk.h"

// Exercise 4. Include the libraries necessaries to use the usb-serial-debug, and tinyusb
// Tehtävä 4 . Lisää usb-serial-debugin ja tinyusbin käyttämiseen tarvittavat kirjastot.


#define BUFFER_SIZE     64
#define DEFAULT_STACK_SIZE 2048
#define CDC_ITF_TX      1


// Tehtävä 3: Tilakoneen esittely Add missing states.
// Exercise 3: Definition of the state machine. Add missing states.
enum state { WAITING=1,DATA_READY};
enum state programState = WAITING;

// Tehtävä 3: Valoisuuden globaali muuttuja
// Exercise 3: Global variable for ambient light
uint32_t ambientLight;

static void btn_fxn(uint gpio, uint32_t eventMask) {
    uint8_t pinValue = gpio_get(LED1);
    pinValue = !pinValue;
    gpio_put(LED1, pinValue);
    // Tehtävä 1: Vaihda LEDin tila.
    //            Tarkista SDK, ja jos et löydä vastaavaa funktiota, sinun täytyy toteuttaa se itse.
    // Exercise 1: Toggle the LED. 
    //             Check the SDK and if you do not find a function you would need to implement it yourself. 
}

static void sensor_task(void *arg){
    (void)arg;
    init_veml6030();

    // Tehtävä 2: Alusta valoisuusanturi. Etsi SDK-dokumentaatiosta sopiva funktio.
    // Exercise 2: Init the light sensor. Find in the SDK documentation the adequate function.
   
    for(;;){
        // Tehtävä 2: Muokkaa tästä eteenpäin sovelluskoodilla. Kommentoi seuraava rivi.
        //
        // Exercise 2: Modify with application code here. Comment following line.
        //             Read sensor data and print it out as string; 
        //tight_loop_contents(); 
        if (programState == WAITING) {
            ambientLight = veml6030_read_light();
            programState = DATA_READY;
        }
         vTaskDelay(pdMS_TO_TICKS(1000));
    }


        // Tehtävä 3:  Muokkaa aiemmin Tehtävässä 2 tehtyä koodia ylempänä.
        //             Jos olet oikeassa tilassa, tallenna anturin arvo tulostamisen sijaan
        //             globaaliin muuttujaan.
        //             Sen jälkeen muuta tilaa.
        // Exercise 3: Modify previous code done for Exercise 2, in previous lines. 
        //             If you are in adequate state, instead of printing save the sensor value 
        //             into the global variable.
        //             After that, modify state





        
        // Exercise 2. Just for sanity check. Please, comment this out
        // Tehtävä 2: Just for sanity check. Please, comment this out
        //printf("sensorTask\n");

        // Do not remove this
    }

static void print_task(void *arg) {
    (void)arg;
    while (!tud_cdc_n_connected(CDC_ITF_TX)) {
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    while(1){
        if (programState == DATA_READY) {
            uint32_t timestamp = (uint32_t)(xTaskGetTickCount() * portTICK_PERIOD_MS);
            //CDC1
            if (tud_cdc_n_connected(CDC_ITF_TX)) {
                char buf[BUFFER_SIZE];
                snprintf(buf, BUFFER_SIZE, "%lu, %lu\n", timestamp, ambientLight);
                tud_cdc_n_write(CDC_ITF_TX, buf, strlen(buf));
                tud_cdc_n_write_flush(CDC_ITF_TX);
            }
            //CDC0
            if (usb_serial_connected()) {
                char debugBuf[BUFFER_SIZE];
                snprintf(debugBuf, BUFFER_SIZE, "Lux: %lu\n", ambientLight);
                usb_serial_print(debugBuf);
                usb_serial_flush();
            }

            programState = WAITING;
        }

        vTaskDelay(pdMS_TO_TICKS(500));
    }
}



// Exercise 4: Uncomment the following line to activate the TinyUSB library.  
// Tehtävä 4:  Poista seuraavan rivin kommentointi aktivoidaksesi TinyUSB-kirjaston. 


static void usbTask(void *arg) {
    (void)arg;
    while (1) {
        tud_task();              // With FreeRTOS wait for events
                                 // Do not add vTaskDelay. 
    }
}

int main() {

    // Exercise 4: Comment the statement stdio_init_all(); 
    //             Instead, add AT THE END OF MAIN (before vTaskStartScheduler();) adequate statements to enable the TinyUSB library and the usb-serial-debug.
    //             You can see hello_dual_cdc for help
    //             In CMakeLists.txt add the cfg-dual-usbcdc
    //             In CMakeLists.txt deactivate pico_enable_stdio_usb
    // Tehtävä 4:  Kommentoi lause stdio_init_all();
    //             Sen sijaan lisää MAIN LOPPUUN (ennen vTaskStartScheduler();) tarvittavat komennot aktivoidaksesi TinyUSB-kirjaston ja usb-serial-debugin.
    //             Voit katsoa apua esimerkistä hello_dual_cdc.
    //             Lisää CMakeLists.txt-tiedostoon cfg-dual-usbcdc
    //             Poista CMakeLists.txt-tiedostosta käytöstä pico_enable_stdio_usb

    //stdio_init_all();

    // Uncomment this lines if you want to wait till the serial monitor is connected
    /*while (!stdio_usb_connected()){
        sleep_ms(10);
    }*/ 
    
    init_hat_sdk();
    sleep_ms(300); //Wait some time so initialization of USB and hat is done.

    // Exercise 1: Initialize the button and the led and define an register the corresponding interrupton.
    //             Interruption handler is defined up as btn_fxn
    // Tehtävä 1:  Alusta painike ja LEd ja rekisteröi vastaava keskeytys.
    //             Keskeytyskäsittelijä on määritelty yläpuolella nimellä btn_fxn
    gpio_init(BUTTON1);
    gpio_set_dir(BUTTON1, GPIO_IN);

    gpio_init(LED1);
    gpio_set_dir(LED1, GPIO_OUT);
    //keskeytys
    gpio_set_irq_enabled_with_callback(BUTTON1, GPIO_IRQ_EDGE_FALL, true, btn_fxn);


    
    
    TaskHandle_t hSensorTask, hPrintTask, hUSB = NULL;

    // Exercise 4: Uncomment this xTaskCreate to create the task that enables dual USB communication.
    // Tehtävä 4: Poista tämän xTaskCreate-rivin kommentointi luodaksesi tehtävän,
    // joka mahdollistaa kaksikanavaisen USB-viestinnän.

    
    xTaskCreate(usbTask, "usb", 2048, NULL, 3, &hUSB);
    #if (configNUMBER_OF_CORES > 1)
        vTaskCoreAffinitySet(hUSB, 1u << 0);
    #endif


    // Create the tasks with xTaskCreate
    BaseType_t result = xTaskCreate(sensor_task, // (en) Task function
                "sensor",                        // (en) Name of the task 
                DEFAULT_STACK_SIZE,              // (en) Size of the stack for this task (in words). Generally 1024 or 2048
                NULL,                            // (en) Arguments of the task 
                2,                               // (en) Priority of this task
                &hSensorTask);                   // (en) A handle to control the execution of this task

    if(result != pdPASS) {
        usb_serial_print("Sensor task creation failed\n");
        return 0;
    }
    result = xTaskCreate(print_task,  // (en) Task function
                "print",              // (en) Name of the task 
                DEFAULT_STACK_SIZE,   // (en) Size of the stack for this task (in words). Generally 1024 or 2048
                NULL,                 // (en) Arguments of the task 
                2,                    // (en) Priority of this task
                &hPrintTask);         // (en) A handle to control the execution of this task

    if(result != pdPASS) {
        usb_serial_print("Print Task creation failed\n");
        return 0;
    }
    tusb_init();
    usb_serial_init();
    vTaskStartScheduler();
    
    // Never reach this line.
    return 0;
}
